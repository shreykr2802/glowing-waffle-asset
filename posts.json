[
    {
        "slug": "understanding-hoisting-and-closures-in-javascript",
        "title": "Understanding Hoisting and Closures in JavaScript",
        "description": "A comprehensive guide to understanding hoisting and closures in JavaScript.",
        "introduction": "In this blog post, we will delve into two important concepts in JavaScript: hoisting and closures. Understanding these concepts is crucial for mastering JavaScript.",
        "date": "18-06-2024",
        "mainImage": "./hoisting-closures.png",
        "tags": ["tech", "javascript", "hoisting", "closures"],
        "readTime": "2 min read",
        "content": [
          {
            "slNo": "1",
            "heading": "What is Hoisting?",
            "html": "JavaScript Hoisting refers to the process whereby the interpreter appears to move the declaration of functions, variables, classes, or imports to the top of their scope, prior to execution of the code.",
            "code": "console.log(x); // Output: undefined\nvar x = 5;\nconsole.log(x); // Output: 5",
            "image": ""
          },
          {
            "slNo": "2",
            "heading": "Hoisting of Functions",
            "html": "The below code runs without any error, despite the hoistedFunction() function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope.",
            "code": "hoistedFunction(); // Output: 'This function has been hoisted.'\n\nfunction hoistedFunction() {\n  console.log('This function has been hoisted.');\n}",
            "image": ""
          },
          {
            "slNo": "3",
            "heading": "Understanding Closures",
            "html": "",
            "code": "function outerFunction(outerVariable) {\n  return function innerFunction(innerVariable) {\n    console.log('Outer Variable: ' + outerVariable);\n    console.log('Inner Variable: ' + innerVariable);\n  };\n}\n\nconst newFunction = outerFunction('outside');\nnewFunction('inside');",
            "image": ""
          },
          {
            "slNo": "4",
            "heading": "Visualizing Closures",
            "html": "",
            "code": "",
            "image": "./closures-visualization.png"
          }
        ],
        "conclusion": "In this post, we explored the concepts of hoisting and closures in JavaScript. By understanding these concepts, you can write more efficient and bug-free code. Hoisting allows variable and function declarations to be moved to the top of their scope, while closures enable functions to access variables from an outer function scope even after the outer function has closed.",
        "artifacts": ["https://developer.mozilla.org/en-US/docs/Glossary/Hoisting", "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"]
      },
      {
        "slug": "understanding-debouncing-in-javascript",
        "title": "Understanding Debouncing in JavaScript",
        "description": "A comprehensive guide to understanding Debouncing in JavaScript.",
        "introduction": "In this comprehensive guide, we will explore debouncing in JavaScript, understand its importance, and learn how to implement it effectively. Whether you are a beginner or an experienced developer, mastering debouncing can significantly improve your web performance.Debouncing is a programming practice used to ensure that a time-consuming task does not fire so often, improving performance and user experience. It's particularly useful in scenarios like window resizing, button clicking, or form input events, where multiple rapid events need to be controlled.",
        "date": "18-06-2024",
        "mainImage": "./deboucing.png",
        "tags": ["tech", "javascript", "deboucing", "webdev"],
        "readTime": "4 min read",
        "content": [
          {
            "slNo": "1",
            "heading": "What is Debouncing?",
            "html": "Debouncing is a technique to limit the rate at which a function is executed. When multiple events are triggered in quick succession, the debounce function will ensure that only the last event in the series triggers the function execution after a specified delay.",
            "codeType": "",
            "code": "",
            "image": ""
          },
          {
            "slNo": "2",
            "heading": "Why Use Debouncing?",
            "html": "<ul><li>Performance Optimization: Prevents performance issues by reducing the number of times a function is called.</li><li>Enhanced User Experience: Avoids the clutter of repeated actions, providing a smoother experience.</li><li>Network Efficiency: Reduces unnecessary network requests when used with event handlers like input fields for live search.</li></ul",
            "codeType": "",
            "code": "",
            "image": ""
          },
          {
            "slNo": "3",
            "heading": "Implementing Debouncing in JavaScript",
            "html": "Here is a simple implementation of a debounce function:",
            "codeType": "javascript",
            "code": "function debounce(func, wait) {\n\tlet timeout;\n\treturn function executedFunction(...args) {\n\n\tconst later = () => {\n\t\tclearTimeout(timeout);\n\t\tfunc(...args);\n\t};\n\n\tclearTimeout(timeout);\n\ttimeout = setTimeout(later, wait);\n\t};\n}",
            "image": ""
          },
          {
            "slNo": "4",
            "heading": "Usage Example",
            "html": "Let's see how we can use the debounce function in a real-world scenario:",
            "codeType": "html",
            "code": "<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t\t<title>Debouncing Example</title>\n\t</head>\n<body>\n<input type=\"text\" id=\"searchBox\" placeholder=\"Type to search...\">\n<script>\n\tconst searchBox = document.getElementById('searchBox');\n\tfunction fetchSuggestions(query) {\n\t\tconsole.log('Fetching suggestions for:', query); // Simulate an API call\n\t}\n\n\tconst debouncedFetchSuggestions = debounce(fetchSuggestions, 300);\n\n\tsearchBox.addEventListener('input', (event) => {\n\t\tdebouncedFetchSuggestions(event.target.value);\n\t});\n\tfunction debounce(func, wait) {\n\t\tlet timeout;\n\t\treturn function executedFunction(...args) {\n\t\t\tconst later = () => {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tfunc(...args);\n\t\t\t};\n\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = setTimeout(later, wait);\n\t\t};\n\t}\n</script>\n</body>\n</html>",
            "image": ""
          },
          {
            "slNo": "5",
            "heading": "In this example:",
            "html": "<ul><li>An input field captures the user's input.</li><li>The fetchSuggestions function is debounced with a delay of 300 milliseconds.</li><li>As the user types, the debouncedFetchSuggestions function is called, ensuring that fetchSuggestions is only executed once the user stops typing for 300 milliseconds.</li></ul>",
            "codeType": "",
            "code": "",
            "image": ""
          }
        ],
        "conclusion": "Debouncing is a simple yet powerful technique to optimize the performance of web applications. By controlling the rate of function execution, it helps in reducing unnecessary computations and improving the overall user experience. Whether you're handling search inputs, resizing windows, or dealing with other rapid events, debouncing can be a valuable tool in your JavaScript arsenal.",
        "artifacts": ["https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous"]
      }
]
